}
}
if(verbose){print('Finding fissions and fusion')}
#go through event times and classify events into types
changes <- data.frame(tidx = event_times)
changes$datetime <- ts[changes$tidx]
changes$event_type <- NA
changes$n_groups_curr <- unlist(lapply(groups_list, length))[event_times]
changes$n_groups_next <- unlist(lapply(groups_list, length))[event_times+1]
changes$n_inds_curr <- changes$n_inds_next <- NA
for(i in 1:nrow(changes)){
t <- changes$tidx[i]
groups_curr <- groups_list[[t]]
groups_next <- groups_list[[t+1]]
changes$n_inds_curr[i] <- sum(unlist(lapply(groups_curr, length)))
changes$n_inds_next[i] <- sum(unlist(lapply(groups_next, length)))
}
changes$event_type[which(changes$n_groups_curr < changes$n_groups_next & changes$n_inds_curr==changes$n_inds_next)] <- 'fission'
changes$event_type[which(changes$n_groups_curr > changes$n_groups_next & changes$n_inds_curr==changes$n_inds_next)] <- 'fusion'
#get groups for fissions and fusions
changes$group_A_idxs <- changes$group_A <- changes$group_B_idxs <- changes$group_B <- list(c(0))
fissions <- which(changes$event_type=='fission')
fusions <- which(changes$event_type=='fusion')
#Identify which subgroups split or merged
if(verbose){print('Determinig which subgroups split and merged')}
for(i in fissions){
groups_curr <- groups_list[[changes$tidx[i]]]
groups_next <- groups_list[[changes$tidx[i]+1]]
n_groups_next <- changes$n_groups_next[i]
n_groups_curr <- changes$n_groups_curr[i]
#if there are only 2 groups at the end, then name them A and B
if(n_groups_next==2){
changes$group_A_idxs[i] <- groups_next[1]
changes$group_B_idxs[i] <- groups_next[2]
}
#if there are more than 2 groups, need to figure out which one changed
if(n_groups_next > 2){
matched_groups <- c()
for(j in 1:n_groups_next){
matched <- F
for(k in 1:n_groups_curr){
if(setequal(groups_next[[j]], groups_curr[[k]])){
matched <- T
}
}
if(matched){
matched_groups <- c(matched_groups, j)
}
}
unmatched_groups <- setdiff(1:n_groups_next, matched_groups)
if(length(unmatched_groups)==2){
changes$group_A_idxs[i] <- groups_next[unmatched_groups[1]]
changes$group_B_idxs[i] <- groups_next[unmatched_groups[2]]
}else{
warning(paste('Could not identify unambiguously subgroups for event',i,
'due to more than 2 unmatched subgroups'))
}
}
}
for(i in fusions){
groups_curr <- groups_list[[changes$tidx[i]]]
groups_next <- groups_list[[changes$tidx[i]+1]]
n_groups_next <- changes$n_groups_next[i]
n_groups_curr <- changes$n_groups_curr[i]
#if there are only 2 groups at the start, then name them A and B
if(n_groups_curr==2){
changes$group_A_idxs[i] <- groups_curr[1]
changes$group_B_idxs[i] <- groups_curr[2]
}
#if there are more than 2 groups, need to figure out which one changed
if(n_groups_curr > 2){
matched_groups <- c()
for(j in 1:n_groups_curr){
matched <- F
for(k in 1:n_groups_next){
if(setequal(groups_curr[[j]], groups_next[[k]])){
matched <- T
}
}
if(matched){
matched_groups <- c(matched_groups, j)
}
}
unmatched_groups <- setdiff(1:n_groups_curr, matched_groups)
if(length(unmatched_groups)==2){
changes$group_A_idxs[i] <- groups_curr[unmatched_groups[1]]
changes$group_B_idxs[i] <- groups_curr[unmatched_groups[2]]
}else{
warning(paste('Could not identify unambiguously subgroups for event',i,
'due to more than 2 unmatched subgroups'))
}
}
}
#get coati names
coati_ids$name_short <- sapply(coati_ids$name, function(x){return(substr(x,1,3))})
for(i in c(fissions,fusions)){
changes$group_A[i] <- list(coati_ids$name_short[changes$group_A_idxs[i][[1]]])
changes$group_B[i] <- list(coati_ids$name_short[changes$group_B_idxs[i][[1]]])
}
#final events dataframe (call it events_detected)
events_detected <- changes[c(fissions, fusions),c('tidx','datetime','event_type','group_A_idxs','group_B_idxs','group_A','group_B')]
#get number of individuals in each subgroup
events_detected$n_A <- sapply(events_detected$group_A_idxs, length)
events_detected$n_B <- sapply(events_detected$group_B_idxs, length)
#sort by time
events_detected <- events_detected[order(events_detected$tidx),]
#add index column
events_detected$event_idx <- 1:nrow(events_detected)
if(verbose){print('Done.')}
#return things
out <- list(events_detected = events_detected, groups_list = groups_list, together = together, changes = changes, R_inner = R_inner, R_outer = R_outer)
return(out)
}
#LIBRARY
library(lubridate)
library(scales)
#----------PARAMETERS - MODIFY HERE--------------
#which group (galaxy or presedente)
group <- 'presedente'
#who is using (ari or emily)
user <- 'emily'
#whether to identify splits and merges automatically (if F) or use manually identified events (if T)
use_manual_events <- T
#---PARAMETERS (probably don't modify)---
#events filename - where to get the split/merge events for manually labeled events
events.filename <- paste0('C:/Users/egrout/Dropbox/coatithon/processed/split_analysis_processed/',group,'_manual_split_merge_clean.csv')
#radii to use
R_inner <- 15
R_outer <- 50
#------TIME ZONE------
#set time zone to UTC to avoid confusing time zone issues
Sys.setenv(TZ='UTC')
#DIRECTORIES AND PARAMETERS
if(user %in% c('Ari','ari')){
codedir <- '~/Dropbox/code_ari/coatithon_code/'
dir <- '~/Dropbox/coati/processed/' #directory where all data is stored
if(group == 'galaxy'){
groupdir <- '~/Dropbox/coati/processed/galaxy/'
} else if(group=='presedente'){
groupdir <- '~/Dropbox/coati/processed/presedente/'
}
} else{
codedir <- 'C:/Users/egrout/Dropbox/coatithon/coatithon_code/'
if(group == 'galaxy'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/"
} else if(group == 'presedente'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/"
}
}
#FUNCTIONS
#read in functions
setwd(codedir)
source('coati_function_library.R')
#LOAD DATA
#navigate into directory
setwd(groupdir)
#read in coati ids
load(file=paste0(group,'_coati_ids.RData'))
#modify coati ids to only include first 3 letters
coati_ids$name_short <- sapply(coati_ids$name, function(x){return(substr(x,1,3))})
#read in timestamp data
load(file=paste0(group,'_xy_highres_level2.RData'))
end(ts)
tail(ts)
as.date(tail(ts))
as.Date(tail(ts))
as.Date(tail(ts))+1
as.Date(tail(ts), n =1)+1
as.Date(tail(ts, n=1), n=1) +1
as.Date(tail(ts, n=1)) +1
(tail(ts, n=1))
(tail(ts, n=1))+1
(tail(ts, n=1))+1000
(tail(ts, n=1))+100000
(tail(ts, n=1))+10000
(tail(ts, n=1))+100000
(tail(ts, n=1))+100000
extra_time <- (tail(ts, n=1))+100000
extra_time
ts <- c(ts, extra_time)
nrow(xs)
1:nrow(xs)
as.vector(1:nrow(xs))
extra_dat <- as.vector(1:nrow(xs))
extra_dat <- <- rep(1, nrow(xs)))
extra_dat <- rep(1, nrow(xs)))
extra_dat <- rep(1, nrow(xs))
xs_ <- cbind(xs, extra_dat )
xs_ <- cbind(xs, 1)
xs_ <- cbind(xs, 1)
extra_dat <- matrix(1, nrow = nrow(xs), ncol = 1)
View(extra_dat)
xs_ <- cbind(xs, extra_dat)
xs_ <- cbind(xs, extra_dat)
xs__ <- cbind(xs, extra_dat)
View(xs__)
#LIBRARY
library(lubridate)
library(scales)
#----------PARAMETERS - MODIFY HERE--------------
#which group (galaxy or presedente)
group <- 'presedente'
#who is using (ari or emily)
user <- 'emily'
#whether to identify splits and merges automatically (if F) or use manually identified events (if T)
use_manual_events <- T
#---PARAMETERS (probably don't modify)---
#events filename - where to get the split/merge events for manually labeled events
events.filename <- paste0('C:/Users/egrout/Dropbox/coatithon/processed/split_analysis_processed/',group,'_manual_split_merge_clean.csv')
#radii to use
R_inner <- 15
R_outer <- 50
#------TIME ZONE------
#set time zone to UTC to avoid confusing time zone issues
Sys.setenv(TZ='UTC')
#DIRECTORIES AND PARAMETERS
if(user %in% c('Ari','ari')){
codedir <- '~/Dropbox/code_ari/coatithon_code/'
dir <- '~/Dropbox/coati/processed/' #directory where all data is stored
if(group == 'galaxy'){
groupdir <- '~/Dropbox/coati/processed/galaxy/'
} else if(group=='presedente'){
groupdir <- '~/Dropbox/coati/processed/presedente/'
}
} else{
codedir <- 'C:/Users/egrout/Dropbox/coatithon/coatithon_code/'
if(group == 'galaxy'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/"
} else if(group == 'presedente'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/"
}
}
#FUNCTIONS
#read in functions
setwd(codedir)
source('coati_function_library.R')
#LOAD DATA
#navigate into directory
setwd(groupdir)
#read in coati ids
load(file=paste0(group,'_coati_ids.RData'))
#modify coati ids to only include first 3 letters
coati_ids$name_short <- sapply(coati_ids$name, function(x){return(substr(x,1,3))})
#read in timestamp data
load(file=paste0(group,'_xy_highres_level2.RData'))
#because the function ignore the last day, adding 1 more day to the data
#getting an extra timestamp for following day
extra_time <- (tail(ts, n=1))+100000
ts <- c(ts, extra_time)
extra_dat <- matrix(1, nrow = nrow(xs), ncol = 1)
xs <- cbind(xs, extra_dat)
ys <- cbind(ys, extra_dat)
#PROCESS
setwd(codedir)
#read in events if using manual events
if(use_manual_events){
events <- read.csv(events.filename, sep=';')
} else{ #otherwise do it automatically
ff_data <- detect_fissions_and_fusions(R_inner = R_inner, R_outer = R_outer, xs, ys, ts, coati_ids)
events <- ff_data$events_detected
}
#whether to identify splits and merges automatically (if F) or use manually identified events (if T)
use_manual_events <- F
#events filename - where to get the split/merge events for manually labeled events
events.filename <- paste0('C:/Users/egrout/Dropbox/coatithon/processed/split_analysis_processed/',group,'_manual_split_merge_clean.csv')
#radii to use
R_inner <- 15
R_outer <- 50
#------TIME ZONE------
#set time zone to UTC to avoid confusing time zone issues
Sys.setenv(TZ='UTC')
if(user %in% c('Ari','ari')){
codedir <- '~/Dropbox/code_ari/coatithon_code/'
dir <- '~/Dropbox/coati/processed/' #directory where all data is stored
if(group == 'galaxy'){
groupdir <- '~/Dropbox/coati/processed/galaxy/'
} else if(group=='presedente'){
groupdir <- '~/Dropbox/coati/processed/presedente/'
}
} else{
codedir <- 'C:/Users/egrout/Dropbox/coatithon/coatithon_code/'
if(group == 'galaxy'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/"
} else if(group == 'presedente'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/"
}
}
#FUNCTIONS
#read in functions
setwd(codedir)
source('coati_function_library.R')
#LOAD DATA
#navigate into directory
setwd(groupdir)
#read in coati ids
load(file=paste0(group,'_coati_ids.RData'))
#modify coati ids to only include first 3 letters
coati_ids$name_short <- sapply(coati_ids$name, function(x){return(substr(x,1,3))})
#read in timestamp data
load(file=paste0(group,'_xy_highres_level2.RData'))
extra_time <- (tail(ts, n=1))+100000
ts <- c(ts, extra_time)
extra_dat <- matrix(1, nrow = nrow(xs), ncol = 1)
xs <- cbind(xs, extra_dat)
ys <- cbind(ys, extra_dat)
#PROCESS
setwd(codedir)
#read in events if using manual events
if(use_manual_events){
events <- read.csv(events.filename, sep=';')
} else{ #otherwise do it automatically
ff_data <- detect_fissions_and_fusions(R_inner = R_inner, R_outer = R_outer, xs, ys, ts, coati_ids)
events <- ff_data$events_detected
}
View(events)
library(lubridate)
library(scales)
#----------PARAMETERS - MODIFY HERE--------------
#which group (galaxy or presedente)
group <- 'presedente'
#who is using (ari or emily)
user <- 'emily'
#whether to identify splits and merges automatically (if F) or use manually identified events (if T)
use_manual_events <- F
#---PARAMETERS (probably don't modify)---
#events filename - where to get the split/merge events for manually labeled events
events.filename <- paste0('C:/Users/egrout/Dropbox/coatithon/processed/split_analysis_processed/',group,'_manual_split_merge_clean.csv')
#radii to use
R_inner <- 15
R_outer <- 50
#------TIME ZONE------
#set time zone to UTC to avoid confusing time zone issues
Sys.setenv(TZ='UTC')
#DIRECTORIES AND PARAMETERS
if(user %in% c('Ari','ari')){
codedir <- '~/Dropbox/code_ari/coatithon_code/'
dir <- '~/Dropbox/coati/processed/' #directory where all data is stored
if(group == 'galaxy'){
groupdir <- '~/Dropbox/coati/processed/galaxy/'
} else if(group=='presedente'){
groupdir <- '~/Dropbox/coati/processed/presedente/'
}
} else{
codedir <- 'C:/Users/egrout/Dropbox/coatithon/coatithon_code/'
if(group == 'galaxy'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/"
} else if(group == 'presedente'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/"
}
}
#FUNCTIONS
#read in functions
setwd(codedir)
source('coati_function_library.R')
#LOAD DATA
#navigate into directory
setwd(groupdir)
#read in coati ids
load(file=paste0(group,'_coati_ids.RData'))
#modify coati ids to only include first 3 letters
coati_ids$name_short <- sapply(coati_ids$name, function(x){return(substr(x,1,3))})
#read in timestamp data
load(file=paste0(group,'_xy_highres_level2.RData'))
#because the function ignore the last day, adding 1 more day to the data
#getting an extra timestamp for following day
extra_time <- (tail(ts, n=1))+100000
ts <- c(ts, extra_time)
#adding an extra xs and ys value to correspond with the additional timestamp
extra_dat <- matrix(1, nrow = nrow(xs), ncol = 1)
xs <- cbind(xs, extra_dat)
ys <- cbind(ys, extra_dat)
#PROCESS
setwd(codedir)
#read in events if using manual events
if(use_manual_events){
events <- read.csv(events.filename, sep=';')
} else{ #otherwise do it automatically
ff_data <- detect_fissions_and_fusions(R_inner = R_inner, R_outer = R_outer, xs, ys, ts, coati_ids)
events <- ff_data$events_detected
}
library(lubridate)
library(scales)
#----------PARAMETERS - MODIFY HERE--------------
#which group (galaxy or presedente)
group <- 'presedente'
#who is using (ari or emily)
user <- 'emily'
#whether to identify splits and merges automatically (if F) or use manually identified events (if T)
use_manual_events <- F
#---PARAMETERS (probably don't modify)---
#events filename - where to get the split/merge events for manually labeled events
events.filename <- paste0('C:/Users/egrout/Dropbox/coatithon/processed/split_analysis_processed/',group,'_manual_split_merge_clean.csv')
#radii to use
R_inner <- 15
R_outer <- 50
#------TIME ZONE------
#set time zone to UTC to avoid confusing time zone issues
Sys.setenv(TZ='UTC')
#DIRECTORIES AND PARAMETERS
if(user %in% c('Ari','ari')){
codedir <- '~/Dropbox/code_ari/coatithon_code/'
dir <- '~/Dropbox/coati/processed/' #directory where all data is stored
if(group == 'galaxy'){
groupdir <- '~/Dropbox/coati/processed/galaxy/'
} else if(group=='presedente'){
groupdir <- '~/Dropbox/coati/processed/presedente/'
}
} else{
codedir <- 'C:/Users/egrout/Dropbox/coatithon/coatithon_code/'
if(group == 'galaxy'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/"
} else if(group == 'presedente'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/"
}
}
#FUNCTIONS
#read in functions
setwd(codedir)
source('coati_function_library.R')
#LOAD DATA
#navigate into directory
setwd(groupdir)
#read in coati ids
load(file=paste0(group,'_coati_ids.RData'))
#modify coati ids to only include first 3 letters
coati_ids$name_short <- sapply(coati_ids$name, function(x){return(substr(x,1,3))})
#read in timestamp data
load(file=paste0(group,'_xy_highres_level2.RData'))
#because the function ignore the last day, adding 1 more day to the data
# #getting an extra timestamp for following day
# extra_time <- (tail(ts, n=1))+100000
# ts <- c(ts, extra_time)
# #adding an extra xs and ys value to correspond with the additional timestamp
# extra_dat <- matrix(1, nrow = nrow(xs), ncol = 1)
# xs <- cbind(xs, extra_dat)
# ys <- cbind(ys, extra_dat)
#
#PROCESS
setwd(codedir)
#read in events if using manual events
if(use_manual_events){
events <- read.csv(events.filename, sep=';')
} else{ #otherwise do it automatically
ff_data <- detect_fissions_and_fusions(R_inner = R_inner, R_outer = R_outer, xs, ys, ts, coati_ids)
events <- ff_data$events_detected
}
#LIBRARY
library(lubridate)
library(scales)
#----------PARAMETERS - MODIFY HERE--------------
#which group (galaxy or presedente)
group <- 'presedente'
#who is using (ari or emily)
user <- 'emily'
#whether to identify splits and merges automatically (if F) or use manually identified events (if T)
use_manual_events <- F
#---PARAMETERS (probably don't modify)---
#events filename - where to get the split/merge events for manually labeled events
events.filename <- paste0('C:/Users/egrout/Dropbox/coatithon/processed/split_analysis_processed/',group,'_manual_split_merge_clean.csv')
#radii to use
R_inner <- 15
R_outer <- 50
#------TIME ZONE------
#set time zone to UTC to avoid confusing time zone issues
Sys.setenv(TZ='UTC')
#DIRECTORIES AND PARAMETERS
if(user %in% c('Ari','ari')){
codedir <- '~/Dropbox/code_ari/coatithon_code/'
dir <- '~/Dropbox/coati/processed/' #directory where all data is stored
if(group == 'galaxy'){
groupdir <- '~/Dropbox/coati/processed/galaxy/'
} else if(group=='presedente'){
groupdir <- '~/Dropbox/coati/processed/presedente/'
}
} else{
codedir <- 'C:/Users/egrout/Dropbox/coatithon/coatithon_code/'
if(group == 'galaxy'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/"
} else if(group == 'presedente'){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/"
}
}
#FUNCTIONS
#read in functions
setwd(codedir)
source('coati_function_library.R')
#LOAD DATA
#navigate into directory
setwd(groupdir)
#read in coati ids
load(file=paste0(group,'_coati_ids.RData'))
#modify coati ids to only include first 3 letters
coati_ids$name_short <- sapply(coati_ids$name, function(x){return(substr(x,1,3))})
#read in timestamp data
load(file=paste0(group,'_xy_highres_level2.RData'))
#because the function ignore the last day, adding 1 more day to the data
#getting an extra timestamp for following day
extra_time <- (tail(ts, n=1))+100000
ts <- c(ts, extra_time)
#adding an extra xs and ys value to correspond with the additional timestamp
extra_dat <- matrix(1, nrow = nrow(xs), ncol = 1)
xs <- cbind(xs, extra_dat)
ys <- cbind(ys, extra_dat)
#PROCESS
setwd(codedir)
#read in events if using manual events
if(use_manual_events){
events <- read.csv(events.filename, sep=';')
} else{ #otherwise do it automatically
ff_data <- detect_fissions_and_fusions(R_inner = R_inner, R_outer = R_outer, xs, ys, ts, coati_ids)
events <- ff_data$events_detected
}
