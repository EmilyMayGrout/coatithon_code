cleaned_diff_time <- cleaned_diff_time[cleaned_diff_time$prev_same_type == T,]
# Create a violin plot for all calls
ggplot(cleaned_diff_time, aes(y = label, x = diff_time_s)) +
geom_violin() +
labs(
title = "Distribution of diff_time for Call Types (diff_time < 60 seconds)",
y = "Call Type",
x = "Time Difference (seconds)"
)
# Filter the data for rows where diff_time is less than 1 second
filtered_data <- cleaned_diff_time[cleaned_diff_time$diff_time_s < 1, ]
#removing calls not interested in as they're not rhythmic
excluded_call_types <- c("growl", "chuckle", "click", "grunt", "chirp grunt", "chirp click", "chirp","bop", "hum", "snore", "squeal chittering")
filtered_data$label[filtered_data$label == "dc"] <- "dolphin call"
#remove points where time difference is 0 because it's impossible to call 2 calls at the same time, so likely a nf caller
filtered_data <- filtered_data[!filtered_data$diff_time_s == 0, ]
filtered_data <- filtered_data %>%
filter(!label %in% excluded_call_types)
# Define the desired order of the labels
desired_order <- c("chitter", "squeal", "dolphin call", "bark", "snort")
# Convert the label variable to a factor with the desired order of levels
filtered_data$label <- factor(filtered_data$label, levels = desired_order)
mean(filtered_data$diff_time_s[filtered_data$label == "chitter"])
sd(filtered_data$diff_time_s[filtered_data$label == "chitter"])
mean(filtered_data$diff_time_s[filtered_data$label == "squeal"])
sd(filtered_data$diff_time_s[filtered_data$label == "squeal"])
mean(filtered_data$diff_time_s[filtered_data$label == "bark"])
sd(filtered_data$diff_time_s[filtered_data$label == "bark"])
mean(filtered_data$diff_time_s[filtered_data$label == "dolphin call"])
sd(filtered_data$diff_time_s[filtered_data$label == "dolphin call"])
png(height = 600, width = 800, units = 'px', filename = paste0(plot_dir, "intercall_timediff.png"))
# Plot the reordered data
ggplot(filtered_data, aes(y = label, x = diff_time_s)) +
geom_violin(fill = "plum2") +
labs(
#title = "Distribution of diff_time for Call Types (diff_time < 1 seconds)",
y = "Call Type",
x = "Time Difference (seconds)") +
geom_jitter(height = 0.15, width = 0, size = 0.01, alpha = 0.1, color = "black") +
theme(legend.title = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.text = element_text(size = 24),
axis.title = element_text(size = 20),
legend.text = element_text(size = 20))
dev.off()
#now want to look at which call follows which call - sequential data
unique(cleaned$label)
call_to_split <- c("chirp grunt", "chirp click", "click grunt")
#double_call <- "chirp grunt"
for (double_call in call_to_split){
call_split <- cleaned %>%
filter(label == double_call) %>%
rowwise() %>%
do(data.frame(
id = .$id,
label = strsplit(double_call, split = " ")[[1]],
datetime = c(.$datetime, .$datetime + seconds(0.1)),
Start = c(.$Start[1], .$Start[1]),
Duration = c(.$Duration[1], .$Duration[1]),
file_name = c(.$file_name[1], .$filename[1]),
date = c(.$date[1], .$date[1]),
time = c(.$time[1], .$time[1]),
#other_col2 = c(.$other_col2[1], .$other_col2[1]),   # Fill in NA with original values
stringsAsFactors = FALSE
))
# Combine with the original dataframe excluding the original "chirp grunt" rows
cleaned <- cleaned %>%
filter(label != double_call) %>%
bind_rows(call_split) %>%
arrange(id, datetime)
}
cleaned$date <- as.Date(cleaned$datetime)
#replace dc with dolphin call
cleaned$label[cleaned$label == "dc"] <- "dolphin call"
# Add a date column if it's not already present
# Prepare the data
calls <- cleaned %>%
arrange(id, datetime) %>%  # Arrange by individual and time
group_by(id) %>%  # Group by individual
mutate(next_call_type = if_else(lead(date) == date, lead(label), NA_character_)) %>%  # Create a column for the next call type
filter(!is.na(label) & !is.na(next_call_type))  # Remove rows where the label or next call type is NA
# Get all unique call types
all_call_types <- unique(c(calls$label, calls$next_call_type))
# Create a complete transition matrix template
empty_transition_matrix <- matrix(0, nrow = length(all_call_types), ncol = length(all_call_types),
dimnames = list(all_call_types, all_call_types))
# Create a list to store matrices for each individual
transition_matrices <- list()
# Get the unique individuals
individuals <- unique(calls$id)
# Generate transition matrices for each individual
for (ind in individuals) {
# Filter data for the individual
individual_calls <- calls %>%
filter(id == ind)
# Create a contingency table (transition matrix)
transition_matrix <- table(individual_calls$label, individual_calls$next_call_type)
# Convert the table to a matrix and ensure it matches the template dimensions
transition_matrix <- as.matrix(transition_matrix)
full_transition_matrix <- empty_transition_matrix
full_transition_matrix[rownames(transition_matrix), colnames(transition_matrix)] <- transition_matrix
# Store the transition matrix in the list
transition_matrices[[ind]] <- full_transition_matrix
}
# Sum transition matrices across individuals
combined_transition_matrix <- Reduce("+", transition_matrices)
# Normalize the combined transition matrix by row sums to get probabilities
combined_transition_matrix <- prop.table(combined_transition_matrix, 1)
# Convert the combined transition matrix to a dataframe for plotting
combined_transition_df <- as.data.frame(as.table(combined_transition_matrix))
colnames(combined_transition_df) <- c("From", "To", "Frequency")
# Remove rows with NA values in the From or To columns
combined_transition_df <- combined_transition_df %>%
filter(!is.na(From) & !is.na(To))
#also filter calls not interested in having in the plot such as snore
combined_transition_df <- combined_transition_df %>%
filter(From != "snore" & To != "snore")
#only plot for rhythmic calls
combined_transition_df <- combined_transition_df %>%
filter(From != "squeal chittering" & To != "squeal chittering")
combined_transition_df <- combined_transition_df %>%
filter(From != "hum" & To != "hum")
combined_transition_df <- combined_transition_df %>%
filter(From != "growl" & To != "growl")
combined_transition_df <- combined_transition_df %>%
filter(From != "bop" & To != "bop")
combined_transition_df <- combined_transition_df %>%
filter(From != "grunt" & To != "grunt")
combined_transition_df <- combined_transition_df %>%
filter(From != "click" & To != "click")
combined_transition_df <- combined_transition_df %>%
filter(From != "chirp" & To != "chirp")
# Plot the combined transition matrix
p <- ggplot(combined_transition_df, aes(x = From, y = To, fill = Frequency)) +
geom_tile(color = "white") +
scale_fill_gradient(low = "white", high = "magenta4") +
labs(title = "Combined Transition Matrix for All Individuals",
x = "From Call Type",
y = "To Call Type") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 22),  # Increase x-axis text size
axis.text.y = element_text(size = 22),  # Increase y-axis text size
axis.title.x = element_text(size = 20),  # Increase x-axis title size
axis.title.y = element_text(size = 20),  # Increase y-axis title size
plot.title = element_text(size = 24),  # Increase plot title size
legend.title = element_text(size = 18),  # Increase legend title size
legend.text = element_text(size = 16)  # Increase legend text size
)
print(p)
ggsave(filename = paste0(plot_dir, 'rhythmic_transition+matrix.png'), plot = p, width = 9, height = 8, dpi = 300)
#get the mean values for each transistion being the same call
same_transition_means <- combined_transition_df %>%
filter(From == To)%>%
summarise(
mean_Frequency = mean(Frequency),
sd_Frequency = sd(Frequency)
)
#--------------------------------------------
# #normalising the data and transition call has to be within 1min of previous call to count
# # Prepare the data
# calls <- cleaned %>%
#   filter(label != "snore") %>%  # Exclude rows where the label is "snore"
#   arrange(id, datetime) %>%  # Arrange by individual and time
#   group_by(id) %>%  # Group by individual
#   mutate(next_call_type = if_else(lead(date) == date & (lead(datetime) - datetime <= minutes(1)), lead(label), NA_character_)) %>%  # Create a column for the next call type within 1 minute
#   filter(!is.na(label) & !is.na(next_call_type))  # Remove rows where the label or next call type is NA
#
# # Get all unique call types
# all_call_types <- unique(c(calls$label, calls$next_call_type))
#
# # Create a complete transition matrix template
# empty_transition_matrix <- matrix(0, nrow = length(all_call_types), ncol = length(all_call_types),
#                                   dimnames = list(all_call_types, all_call_types))
#
# # Create a list to store matrices for each individual
# transition_matrices <- list()
#
# # Get the unique individuals
# individuals <- unique(calls$id)
#
# # Generate transition matrices for each individual
# for (ind in individuals) {
#   # Filter data for the individual
#   individual_calls <- calls %>%
#     filter(id == ind)
#
#   # Create a contingency table (transition matrix)
#   transition_matrix <- table(individual_calls$label, individual_calls$next_call_type)
#
#   # Convert the table to a matrix and ensure it matches the template dimensions
#   transition_matrix <- as.matrix(transition_matrix)
#   full_transition_matrix <- empty_transition_matrix
#   full_transition_matrix[rownames(transition_matrix), colnames(transition_matrix)] <- transition_matrix
#
#   # Normalize the transition matrix by the counts of the "From" call types
#   from_call_counts <- rowSums(full_transition_matrix)
#   normalized_transition_matrix <- sweep(full_transition_matrix, 1, from_call_counts, FUN = "/")
#   normalized_transition_matrix[is.nan(normalized_transition_matrix)] <- 0  # Replace NaN with 0
#
#   # Store the normalized transition matrix in the list
#   transition_matrices[[ind]] <- normalized_transition_matrix
# }
#
# # Sum normalized transition matrices across individuals
# combined_normalized_transition_matrix <- Reduce("+", transition_matrices)
#
# # Convert the combined normalized transition matrix to a dataframe for plotting
# combined_transition_df <- as.data.frame(as.table(combined_normalized_transition_matrix))
# colnames(combined_transition_df) <- c("From", "To", "Frequency")
#
# # Remove rows with NA values in the From or To columns
# combined_transition_df <- combined_transition_df %>%
#   filter(!is.na(From) & !is.na(To))
#
# # Remove rows and columns where the call type is "snore"
# combined_transition_df <- combined_transition_df %>%
#   filter(From != "snore" & To != "snore")
#
# # Plot the combined normalized transition matrix
# p <- ggplot(combined_transition_df, aes(x = From, y = To, fill = Frequency)) +
#   geom_tile(color = "white") +
#   scale_fill_gradient(low = "white", high = "steelblue") +
#   labs(title = "Combined Normalized Transition Matrix for All Individuals",
#        x = "From Call Type (Initial Call)",
#        y = "To Call Type (Subsequent Call)") +  # Explicitly state which call is first and which is second
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
#
# print(p)
#-----------------------------------------
View(cleaned_diff_time)
View(filtered_data)
library(lubridate)
library(dbscan)
#DIRECTORIES AND PARAMETERS
R_inner <- 15
R_outer <- 50
codedir <- '~/Dropbox/code_ari/coatithon_code/'
dir <- '~/Dropbox/coati/processed/' #directory where all data is stored
group <- 'presedente' #subdirectory where the group data is stored
#get directory to group data
groupdir <- paste0(dir,group)
#for Emily:
codedir <- 'C:/Users/egrout/Dropbox/coatithon/coatithon_code/'
#groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/"
#plot_dir <- 'C:/Users/egrout/Dropbox/coatithon/results/galaxy_results/level2/'
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/"
plot_dir <- 'C:/Users/egrout/Dropbox/coatithon/results/presedente_results/level2/'
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
#LOAD DATA
#navigate into directory
setwd(codedir)
#read in events
events <- read.csv(paste0('C:/Users/egrout/Dropbox/coatithon/processed/split_analysis_processed/',group,'_manual_split_merge_clean.csv'), sep=';')
#read in coati ids
setwd(groupdir)
load(file=paste0(group,'_coati_ids.RData'))
#read in timestamp data - notice the level number, if 2, then its not got GPS speed errors
load(file=paste0(group,'_xy_highres_level2.RData'))
ff_data_50 <- detect_fissions_and_fusions(R_inner = 15, R_outer = 50, xs, ys, ts, coati_ids)
#saving the events_detected dataframe of the ff_data_50 list
if(group == 'galaxy'){
gal_events_detected <- ff_data_50$events_detected
save(gal_events_detected, file = "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/gal_events_detected.Rda")
}else if(group == 'presedente'){
pres_events_detected <- ff_data_50$events_detected
save(pres_events_detected, file = "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/pres_events_detected.Rda") }
#saving as a csv for documenting erroneous events in the google sheets
#write.csv(gal_events_detected[, c(1,2,3,8,9,10)], file = "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/gal_events_detected.csv")
write.csv(pres_events_detected[, c(1,2,3,8,9,10)], file = "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/pres_events_detected.csv")
#looking at one event
analyse_ff_event(387, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
#looking at one event
analyse_ff_event(387, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
#looking at one event
analyse_ff_event(1, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
#looking at one event
analyse_ff_event(2, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
plotdir
paste0(plot_dir, i , ,'_event.png')
i = 1
paste0(plot_dir, i , ,'_event.png')
paste0(plot_dir, i  ,'_event.png')
paste0(plot_dir,"events/", i  ,'_event.png')
for (i in 1:length(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(2, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
}
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
for (i in 1:length(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(2, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
}
for (i in 1:length(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(2, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
}
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
for (i in 1:length(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(2, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
}
for (i in 1:length(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
}
i = 11
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
length(ff_data_50$events_detected)
for (i in 1:nrow(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
}
group <- 'galaxy' #subdirectory where the group data is stored
#get directory to group data
groupdir <- paste0(dir,group)
#for Emily:
codedir <- 'C:/Users/egrout/Dropbox/coatithon/coatithon_code/'
#groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/"
#plot_dir <- 'C:/Users/egrout/Dropbox/coatithon/results/galaxy_results/level2/'
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/"
plot_dir <- 'C:/Users/egrout/Dropbox/coatithon/results/presedente_results/level2/'
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
#LOAD DATA
#navigate into directory
setwd(codedir)
#read in events
events <- read.csv(paste0('C:/Users/egrout/Dropbox/coatithon/processed/split_analysis_processed/',group,'_manual_split_merge_clean.csv'), sep=';')
#read in coati ids
setwd(groupdir)
load(file=paste0(group,'_coati_ids.RData'))
library(lubridate)
library(dbscan)
#DIRECTORIES AND PARAMETERS
R_inner <- 15
R_outer <- 50
codedir <- '~/Dropbox/code_ari/coatithon_code/'
dir <- '~/Dropbox/coati/processed/' #directory where all data is stored
group <- 'galaxy' #subdirectory where the group data is stored
#get directory to group data
groupdir <- paste0(dir,group)
#for Emily:
codedir <- 'C:/Users/egrout/Dropbox/coatithon/coatithon_code/'
#groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/"
#plot_dir <- 'C:/Users/egrout/Dropbox/coatithon/results/galaxy_results/level2/'
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/"
plot_dir <- 'C:/Users/egrout/Dropbox/coatithon/results/presedente_results/level2/'
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
#LOAD DATA
#navigate into directory
setwd(codedir)
#read in events
events <- read.csv(paste0('C:/Users/egrout/Dropbox/coatithon/processed/split_analysis_processed/',group,'_manual_split_merge_clean.csv'), sep=';')
#read in coati ids
setwd(groupdir)
load(file=paste0(group,'_coati_ids.RData'))
library(lubridate)
library(dbscan)
#DIRECTORIES AND PARAMETERS
R_inner <- 15
R_outer <- 50
codedir <- '~/Dropbox/code_ari/coatithon_code/'
dir <- '~/Dropbox/coati/processed/' #directory where all data is stored
group <- 'galaxy' #subdirectory where the group data is stored
#get directory to group data
groupdir <- paste0(dir,group)
#for Emily:
codedir <- 'C:/Users/egrout/Dropbox/coatithon/coatithon_code/'
if(group == "galaxy"){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/"
plot_dir <- 'C:/Users/egrout/Dropbox/coatithon/results/galaxy_results/level2/'
} else if (group == "presedente"){
groupdir <- "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/"
plot_dir <- 'C:/Users/egrout/Dropbox/coatithon/results/presedente_results/level2/'
}
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
#LOAD DATA
#navigate into directory
setwd(codedir)
#read in events
events <- read.csv(paste0('C:/Users/egrout/Dropbox/coatithon/processed/split_analysis_processed/',group,'_manual_split_merge_clean.csv'), sep=';')
#read in coati ids
setwd(groupdir)
load(file=paste0(group,'_coati_ids.RData'))
#read in timestamp data - notice the level number, if 2, then its not got GPS speed errors
load(file=paste0(group,'_xy_highres_level2.RData'))
ff_data_50 <- detect_fissions_and_fusions(R_inner = 15, R_outer = 50, xs, ys, ts, coati_ids)
#saving the events_detected dataframe of the ff_data_50 list
if(group == 'galaxy'){
gal_events_detected <- ff_data_50$events_detected
save(gal_events_detected, file = "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/gal_events_detected.Rda")
}else if(group == 'presedente'){
pres_events_detected <- ff_data_50$events_detected
save(pres_events_detected, file = "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/pres_events_detected.Rda") }
#saving as a csv for documenting erroneous events in the google sheets
#write.csv(gal_events_detected[, c(1,2,3,8,9,10)], file = "C:/Users/egrout/Dropbox/coatithon/processed/2022/galaxy/gal_events_detected.csv")
write.csv(pres_events_detected[, c(1,2,3,8,9,10)], file = "C:/Users/egrout/Dropbox/coatithon/processed/2023/presedente/pres_events_detected.csv")
#looking at one event
for (i in 1:nrow(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
}
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
analyse_ff_event(10, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
analyse_ff_event(10, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
analyse_ff_event(10, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
analyse_ff_event(10, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
for (i in 1:nrow(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
}
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
analyse_ff_event(10, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
analyse_ff_event(10, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
for (i in 1:nrow(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(10, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
}
for (i in 1:nrow(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
}
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
for (i in 1:nrow(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
}
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
for (i in 1:nrow(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
}
#SOURCE FUNCTIONS
setwd(codedir)
source('coati_function_library.R')
for (i in 1:nrow(ff_data_50$events_detected)){
png(height = 600, width = 600, units = 'px', filename = paste0(plot_dir,"events/", i  ,'_event.png'))
analyse_ff_event(i, events = ff_data_50$events_detected, xs, ys, ts, max_time = 600, plot = T)
dev.off()
}
